<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Space Invaders (Pure HTML/CSS/JS)</title>
<style>
  html,body{margin:0;padding:0;background:#000;color:#0f0;font-family:"Courier New",monospace;height:100%;display:flex;align-items:center;justify-content:center;}
  #wrapper{display:flex;flex-direction:column;align-items:center;gap:8px;position:relative;}
  canvas{background:#111;border:2px solid #0f0;image-rendering:pixelated;}
  #info{text-align:center;font-size:14px;line-height:1.4;white-space:pre-line;}
  a{color:#0f0;}

  /* ───── モバイル用コントローラー ───── */
  #mobileControls{display:none;position:absolute;bottom:12px;left:50%;transform:translateX(-50%);gap:16px;user-select:none;}
  #mobileControls button{width:64px;height:64px;background:#111;border:2px solid #0f0;color:#0f0;font-size:28px;border-radius:8px}
  #mobileControls button:active{background:#0f0;color:#000}
</style>
</head>
<body>
<div id="wrapper">
  <canvas id="game" width="480" height="640"></canvas>
  <div id="info"></div>

  <!-- 追加：モバイル操作ボタン -->
  <div id="mobileControls">
    <button id="btnLeft">◀</button>
    <button id="btnFire">●</button>
    <button id="btnRight">▶</button>
  </div>
</div>

<script>
(() => {
  let rafStarted = false;
  const _origRAF = window.requestAnimationFrame;
  window.requestAnimationFrame = function (cb) {
    rafStarted = true;
    return _origRAF.call(this, cb);
  };
  function startMainLoop() {
    requestAnimationFrame(loop);         // 1 フレームだけでも走れば後は普通に rAF
    setTimeout(() => {                   // 0.4 秒で動かないならフォールバック
      if (!rafStarted) {
        console.log('[Invaders] rAF blocked → setInterval 60fps');
        setInterval(() => loop(performance.now()), 1000 / 60);
      }
    }, 400);
  }
  
  const canvas = document.getElementById('game');
  const ctx    = canvas.getContext('2d');
  const info   = document.getElementById('info');

  /* =========[ 省略なしで元コードここから ]========= */
  const WIDTH  = canvas.width;
  const HEIGHT = canvas.height;
  const GAME_STATE={TITLE:0,PLAYING:1,GAMEOVER:2,CLEAR:3};
  let state=GAME_STATE.TITLE,lastTime=0;
  const keys={};
  const bullets=[],enemies=[];
  let enemyDir=1,enemyStepDown=false,enemySpeed=30,enemyShootTimer=0,enemyShootInterval=1.8;
  let player=null,lives=3,score=0,bestScore=Number(localStorage.getItem('invaders_best'))||0;
  const PLAYER_SPEED=260,BULLET_SPEED=400,ENEMY_BULLET_SPEED=180;

  const audioCtx=new(window.AudioContext||window.webkitAudioContext)();
  function beep(freq=440,duration=0.1,type='square',vol=0.15){
    const o=audioCtx.createOscillator(),g=audioCtx.createGain();
    o.type=type;o.frequency.value=freq;g.gain.value=vol;o.connect(g).connect(audioCtx.destination);
    o.start();o.stop(audioCtx.currentTime+duration);
  }

  function resetGame(){
    bullets.length=enemies.length=0;
    lives=3;score=0;enemyDir=1;enemySpeed=30;enemyShootTimer=0;
    player={x:WIDTH/2-16,y:HEIGHT-60,w:32,h:16};
    for(let r=0;r<5;r++)for(let c=0;c<10;c++){
      enemies.push({x:40+c*36,y:80+r*32,w:24,h:16,alive:true});
    }
  }

  const rectHit=(a,b)=>!(a.x+a.w<b.x||a.x>b.x+b.w||a.y+a.h<b.y||a.y>b.y+b.h);

  function handleInput(dt){
    if(keys['ArrowLeft']||keys['a'])player.x-=PLAYER_SPEED*dt;
    if(keys['ArrowRight']||keys['d'])player.x+=PLAYER_SPEED*dt;
    player.x=Math.max(0,Math.min(WIDTH-player.w,player.x));
  }

  function shootPlayer(){
    if(player._cooldown>0)return;
    bullets.push({x:player.x+player.w/2-2,y:player.y-8,w:4,h:8,dy:-BULLET_SPEED,from:'player'});
    player._cooldown=0.25;beep(880,0.07,'square',0.08);
  }

  function updateBullets(dt){
    bullets.forEach(b=>b.y+=b.dy*dt);
    for(let i=bullets.length-1;i>=0;i--)if(bullets[i].y<-20||bullets[i].y>HEIGHT+20)bullets.splice(i,1);
  }

  function updatePlayerCooldown(dt){if(player._cooldown>0)player._cooldown-=dt;}

  // function updateEnemies(dt){
  //   const alive=enemies.filter(e=>e.alive);if(!alive.length){state=GAME_STATE.CLEAR;updateBest();return;}
  //   const dx=enemySpeed*dt*enemyDir;let hitEdge=false;
  //   alive.forEach(e=>{e.x+=dx;if(e.x<10||e.x+e.w>WIDTH-10)hitEdge=true;});
  //   if(hitEdge){enemyDir*=-1;enemyStepDown=true;}
  //   if(enemyStepDown){
  //     alive.forEach(e=>{e.y+=12;if(e.y+e.h>=player.y){lives=0;state=GAME_STATE.GAMEOVER;updateBest();}});
  //     enemyStepDown=false;
  //     // if (enemySpeed < 60) enemySpeed+=3;
  //   }
  //   enemyShootTimer-=dt;
  //   if(enemyShootTimer<=0){
  //     enemyShootTimer=enemyShootInterval;
  //     const cols={};
  //     alive.forEach(e=>{const col=Math.round(e.x/36);if(!cols[col]||cols[col].y<e.y)cols[col]=e;});
  //     const list=Object.values(cols);if(list.length){
  //       const s=list[Math.random()*list.length|0];
  //       bullets.push({x:s.x+s.w/2-2,y:s.y+s.h+2,w:4,h:10,dy:ENEMY_BULLET_SPEED,from:'enemy'});
  //       beep(220,0.08,'sawtooth',0.05);
  //     }
  //   }
  // }

  function updateEnemies(dt){
    const alive = enemies.filter(e => e.alive);
    if (!alive.length) { state = GAME_STATE.CLEAR; updateBest(); return; }
    
    const dx = enemySpeed * dt * enemyDir;
      
    /* フォーメーションの左右端を取得 */
    let minX = Infinity, maxX = -Infinity;
    alive.forEach(e => {
      if (e.x < minX) minX = e.x;
      if (e.x + e.w > maxX) maxX = e.x + e.w;
    });

    /* 次フレームで端に当たるか？ */
    const hitEdge =
          (enemyDir === 1 && maxX + dx > WIDTH - 10) ||
          (enemyDir === -1 && minX + dx < 10);

    if (hitEdge) {
      /* 方向を反転しつつ一段だけ下げる */
      enemyDir *= -1;
      alive.forEach(e => {
        e.y += 12;
        /* 底に到達したら即ゲームオーバー */
        if (e.y + e.h >= player.y) {
          lives = 0;
          state = GAME_STATE.GAMEOVER;
          updateBest();
        }
      });
    } else {
      /* 端に当たらないなら横移動 */
      alive.forEach(e => { e.x += dx; });
    }

    /* ---- 射撃処理はそのまま ---- */
    enemyShootTimer -= dt;
    if (enemyShootTimer <= 0) {
      enemyShootTimer = enemyShootInterval;
      const cols = {};
      alive.forEach(e => {
        const col = Math.round(e.x / 36);
        if (!cols[col] || cols[col].y < e.y) cols[col] = e;
      });
      const list = Object.values(cols);
      if (list.length) {
        const s = list[Math.random() * list.length | 0];
        bullets.push({ x: s.x + s.w / 2 - 2, y: s.y + s.h + 2, w: 4, h: 10,
                       dy: ENEMY_BULLET_SPEED, from: 'enemy' });
        beep(220, 0.08, 'sawtooth', 0.05);
      }
    }
  }

  function checkCollisions(){
    bullets.forEach(b=>{
      if(b.from==='player'){
        enemies.forEach(e=>{if(e.alive&&rectHit(b,e)){e.alive=false;b._delete=true;score+=10;beep(660,0.06,'triangle',0.07);}});
      }else if(b.from==='enemy'&&rectHit(b,player)){b._delete=true;lives--;beep(110,0.2,'square',0.2);
        if(lives<=0){state=GAME_STATE.GAMEOVER;updateBest();}
      }
    });
    for(let i=bullets.length-1;i>=0;i--)if(bullets[i]._delete)bullets.splice(i,1);
  }

  const drawText=(t,x,y,s=16,a='left')=>{ctx.fillStyle='#0f0';ctx.font=s+'px monospace';ctx.textAlign=a;ctx.fillText(t,x,y);}
  const drawPlayer=()=>{ctx.fillStyle='#0f0';ctx.fillRect(player.x,player.y,player.w,player.h);ctx.fillRect(player.x+player.w/2-2,player.y-6,4,6);}
  const drawEnemies=()=>{ctx.fillStyle='#0f0';enemies.forEach(e=>e.alive&&ctx.fillRect(e.x,e.y,e.w,e.h));}
  const drawBullets=()=>{ctx.fillStyle='#0f0';bullets.forEach(b=>ctx.fillRect(b.x,b.y,b.w,b.h));}
  const renderHUD=()=>{drawText(`SCORE: ${score}`,10,20);drawText(`LIVES: ${lives}`,WIDTH-10,20,16,'right');}
  const renderTitle=()=>{ctx.clearRect(0,0,WIDTH,HEIGHT);
    drawText('SPACE INVADERS',WIDTH/2,HEIGHT/2-60,28,'center');
    drawText('Press ENTER or TAP to START',WIDTH/2,HEIGHT/2-10,16,'center');
    drawText(`BEST SCORE: ${bestScore}`,WIDTH/2,HEIGHT/2+30,16,'center');
    drawText('Move: ← →  Shoot: SPACE',WIDTH/2,HEIGHT/2+60,14,'center');
  }
  const renderGameOver = win => {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawText(win ? 'YOU WIN!' : 'GAME OVER', WIDTH/2, HEIGHT/2 - 40, 28, 'center');
    drawText(`SCORE: ${score}`, WIDTH/2, HEIGHT/2, 18, 'center');
    drawText(`BEST: ${bestScore}`, WIDTH/2, HEIGHT/2 + 30, 16, 'center');
    drawText('Tap to Restart (R key on PC)', WIDTH/2, HEIGHT/2 + 70, 16, 'center'); // ←ここだけ文言変更
  };
  function updateBest(){if(score>bestScore){bestScore=score;localStorage.setItem('invaders_best',bestScore);}}

  function loop(ts){
    let dt = (ts - lastTime) / 1000;
    lastTime = ts;
    if (dt > 0.03) dt = 0.03;

    switch(state){
      case GAME_STATE.TITLE:renderTitle();break;
      case GAME_STATE.PLAYING:
        ctx.clearRect(0,0,WIDTH,HEIGHT);
        handleInput(dt);updatePlayerCooldown(dt);updateEnemies(dt);
        updateBullets(dt);checkCollisions();
        drawEnemies();drawPlayer();drawBullets();renderHUD();break;
      case GAME_STATE.GAMEOVER:renderGameOver(false);break;
      case GAME_STATE.CLEAR:renderGameOver(true);break;
    }
    requestAnimationFrame(loop);
  }

  /* =========[ キーボード & デスクトップ系入力 ]========= */
  window.addEventListener('keydown',e=>{
    keys[e.key]=true;
    if(state===GAME_STATE.PLAYING&&(e.key===' '||e.key==='Spacebar'))shootPlayer();
    if(state===GAME_STATE.TITLE&&e.key==='Enter'){resetGame();state=GAME_STATE.PLAYING;}
    if((state===GAME_STATE.GAMEOVER||state===GAME_STATE.CLEAR)&&e.key.toLowerCase()==='r'){resetGame();state=GAME_STATE.PLAYING;}
  });
  window.addEventListener('keyup',e=>{keys[e.key]=false;});
  canvas.addEventListener('click', () => {
  if (state === GAME_STATE.TITLE) {
      resetGame();
      state = GAME_STATE.PLAYING;
    } else if (state === GAME_STATE.PLAYING) {
      shootPlayer();
    } else if (state === GAME_STATE.GAMEOVER || state === GAME_STATE.CLEAR) {
      // ★ 追加：リザルト画面でもタップでリトライ
      resetGame();
      state = GAME_STATE.PLAYING;
    }
  });

  /* =========[ 追加：モバイル ボタン入力 ]========= */
  const isTouch='ontouchstart'in window||navigator.maxTouchPoints>0;
  if(isTouch){
    const mc=document.getElementById('mobileControls');
    mc.style.display='flex';
    const btnL=document.getElementById('btnLeft');
    const btnR=document.getElementById('btnRight');
    const btnF=document.getElementById('btnFire');

    const bindHold=(btn,key)=>{
      const down=ev=>{ev.preventDefault();keys[key]=true;};
      const up  =ev=>{ev.preventDefault();keys[key]=false;};
      btn.addEventListener('touchstart',down,{passive:false});
      btn.addEventListener('touchend',up);
      btn.addEventListener('touchcancel',up);
      btn.addEventListener('mousedown',down);
      btn.addEventListener('mouseup',up);
      btn.addEventListener('mouseleave',up);
    };
    bindHold(btnL,'ArrowLeft');
    bindHold(btnR,'ArrowRight');

    const fire=ev=>{ev.preventDefault();shootPlayer();};
    btnF.addEventListener('touchstart',fire,{passive:false});
    btnF.addEventListener('mousedown',fire);
  }

  info.textContent='ブラウザですぐ遊べるスペースインベーダー風ゲームです。\n'+
                   '・← → で移動 / SPACEでショット / Rでリスタート\n'+
                   '・スマホでは下のボタンを利用 / タップでショット\n'+
                   '・音が出ます（ミュートしたい場合はブラウザの音量を調整）';

  startMainLoop();

  /* … 既存コードの直後または即時関数内に追加 … */
  
  // 1) モバイルボタンは常に表示してしまう方が安全
  document.getElementById('mobileControls').style.display = 'flex';
  
  // 2) AudioContext が停止していたら最初のタップで再開
  document.addEventListener('touchend', () => {
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
  }, { once:true });
  
  // 3) エディタ／PC用に canvas をクリックしたらフォーカス
  canvas.tabIndex = 0;
  canvas.addEventListener('click', () => canvas.focus());



  (function(){
  let rafStarted = false;
  const origRAF  = window.requestAnimationFrame;
  window.requestAnimationFrame = function(cb){
    rafStarted = true;
    return origRAF.call(this, cb);
  };

  // 0.5 秒待っても rafStarted が true にならなければ setInterval で代替
  setTimeout(()=>{
    if(!rafStarted){
      console.log('[Invaders] rAF not firing, switching to setInterval');
      let last = performance.now();
      setInterval(()=>{
        const now = performance.now();
        cbLoop(now);          // ← 元のゲームループ関数名 (loop) をラップして呼ぶ
        last = now;
      }, 1000/60);
    }
  }, 500);

  // Unity Editor / 実機へデバッグ転送（任意）
  const unity = window.Unity || (msg=>{});
  console.log = (...a)=>{ unity.call('[JS] '+a.join(' ')); };
  })
})();
</script>

</body>
</html>
